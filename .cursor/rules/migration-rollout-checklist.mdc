---
description: Require migration rollout order, risk notes, and execution verification for schema-coupled changes
globs: migrations/**/*.sql
alwaysApply: true
---

# Migration Rollout Checklist

Use this rule for migrations tied to API/UI behavior.

Every schema-coupled change summary must include:

- required migration files
- explicit apply order
- which runtime paths depend on each migration
- rollback/fallback note if migration is delayed

## Guardrail

If API code assumes new columns/tables, do not present task as complete without calling out migration dependency.

## Execution Verification

Before committing migration files:

1. Apply each migration to a development database (e.g. `supabase db push` or `psql -f`).
2. Confirm the migration succeeds without errors.
3. Verify new tables/columns exist with a quick query (e.g. `\dt` or `SELECT * FROM information_schema.columns WHERE table_name = '...'`).
4. If migrations have ordering dependencies, apply them in the documented order and confirm each step.

A migration that has not been executed against a real database is untested code.

## File-on-Disk Requirement

When a schema change is applied via an MCP tool (e.g. `supabase apply_migration`, `execute_sql`), a corresponding migration file MUST also be written to `migrations/` in the same session.

- The file name must follow the project's naming convention (e.g. `YYYY_MM_DD_description.sql`).
- The file content must match what was executed.
- If the MCP tool was used to apply the migration, state explicitly in the handoff: "Migration applied via MCP tool. File written to `migrations/YYYY_MM_DD_*.sql` for traceability."

A schema change with no migration file on disk is **untracked schema drift** and will cause environment divergence on rebuild or team onboarding.
